# Klaytn-study-1
- 섹션0. 1. 인트로

- 섹션1. 2.기존 블록체인 플랫폼의 약점
  - scalability
  - Finality 
  - fork

- 섹션2. 3.클레이튼 이해하기
  - 합의
  - 블록 생성 및 전파
  - 네트워크 구조
  - 코어 셸
  - 서비스 체인
  - 이더리움과 클레이튼의 차이

## 섹션0. 카카오의 블록체인 Klaytn

- 특징
  - TPS 3000+
  - 확장성&privacy
  - 저렴한 TX fee
  - solidity 문법 지원
  - Truffle Framework 지원

- 툴
  - wallet
  - IDE
  - scope

## 섹션1.

### Scalability(확장성)

#### 기존 블록체인 플랫폼의 약점 : TPS + Block Interval

1. TPS: Transaction per second) 초당 몇개의 거래를 처리하는지 나타내는 지표

> TPS가 높다는 것은 초당 처리량이 많다는 의미
> ex) VISA- tps 1700, 비트코인 - tps 7, 이더리움- tps 15-20
> -> 현재 비트코인과 이더리움의 tps 가 VISA의 tps보다 현저히 낮기 때문에 VISA와 블록체인 시스템의 접목이 어려운 것이다!

2. Block Interval: 블록생성간격

> ex) 비트코인 - 10분, 이더리움 - 15~20초
> ex2) ETH : 20tps & 15초 block interval
> 1초에 20*15 =300 transactions 거래 가능
> TPS가 10,000& block interval이 10분 이면?
> = 1초에 10,000개의 트랜잭션을 생성하는데, 하나의 블록을 만드는데 10분이 걸림

#### 기존의 블록체인은 왜 느린가?

-> 참여자가 많아질수록 속도가 빨라지는 시스템이 아니기 때문
->'모든' 노드들이 똑같은 일을 하는 상태가 블록체인의 처리 과정이며, 이 때문에 가장 성능이 낮은 노드에 의해 전체 성능이 결정된다.

#### 비트코인 & 이더리움

1. 많은 양의 트랜잭션 처리하기 부족

2. 네트워크 자체의 속도가 느림

Finality(TX가 변경불가라는 합리적인 보장을 받기까지 기다려야되는 시간)
블록이 Final 하다는 건? 블록에 담긴 TX(거래)가 바뀔 수 없다는 걸 보증
ex) 비트코인&이더리움: 최종성 부족, 확률론적 최종성만 제공
빨리 처리된 Finality는 중요한 business 자산임

#### 비트코인

블록 채굴 평균 시간)10분, Finality까지의 평균 시간)60분(6번의 검증)

#### 이더리움

블록 채굴 평균 시간)15초, finality까지의 평균 시간)6분(25번의 검증)

- Fork: 블록들의 연결이 두 개 이상으로 분기되는 현상

작업증명(PoW방식)

:블록체인에 블록을 추가하기 위해서는 문제를 풀어야 함(Hash 값 찾기)

Longest Chain Rule을 따른다.


<img src="https://user-images.githubusercontent.com/57217495/68576061-b70c1900-04b0-11ea-9546-6648348c7f40.PNG" width= "90%"></img>


->어떤 것으로 정해질 지 모르는 상황, 이것을 명명하는게 fork
이러한 분기문은 "컴퓨팅 파워를 낭비한다는 점에서" 비효율적이라고 할 수 있음.
51%의 의미- 51%의 지분율을 가지고 있으면 결정된다는 의미.

## 섹션2. 클레이튼 이해하기

### 1. 합의

public blockchain: PoW, PoS 등등

private blockchain: pBFT,Raft 등등

#### BFT(비잔티움 결함 허용)

-참여 노드 수 제한 -> 성능 높임

-분산화 약화 & 투명성 저하(소규모 혜택)

cf)비잔티움 문제: 어떤 사용자가 악의적으로 데이터를 변경했을 경우 시스템에 치명적인 오류가 발생할 수 있다는 문제를 제기한 내용

#### 클레이튼 합의 알고리즘(IBFT)

-이스탄불 비잔티움 결함 허용

-공개를 통한 개인적인 합의 신뢰 모델

->퍼블릭 체인과 프라이빗 체인의 성격을 동시에 지니고 있다는 의미

-합의 달성 소수 private 노드

-블록 생성결과 접근 및 검증노드

https://user-images.githubusercontent.com/57217495/68576105-d1de8d80-04b0-11ea-803c-5f0454cbfd3e.PNG

-> 2/3 이상이 허락 시 승인

(장점) 합의 노드들 즉시 완결성을 가짐

(단점) finality 부재 X/ 통신량 많다

</hr>

### 2. 블록 생성 및 전파

블록 생성 사이클
블록 생성 주기 = 라운드 (round)

블록 생성 간격 = 약 1초

2)제안자와 위원회 선택

제안자- proposer, 위원회 -validator

제안자를 무작위 &결정적으로 governance council(합의노드들) 노드들 중 뽑음

각각의 합의 노드가 가장 최근의 블록 헤더에서 파생된 난수 사용, 자기가 라운드에서 선택 되었는지 증명

3)블록 제안과 검증

제안자의 공개 키를 통해 입증 가능한 암호 증명을 사용

(+ 위원회도 입증 필요)

누가 제안자이고 누가 위원회인지 파악이 되면 제안자가 블록을 만들고 합의

4)블록 전파(위원회 2/3이상이 승인 필요)

프록시 노드를 통해 엔드포인트 노드들에게 전달됨

</hr>

### 3. 네트워크 구조


https://user-images.githubusercontent.com/57217495/68576123-d86d0500-04b0-11ea-8ee5-b220215377e7.PNG


-크게 CNN, PNN, ENN으로 구분할 수 있으며, CNN과 PNN은 corecell network 를 구성하고, ENN은 Endpoint node network를 구성함.

-CNN은 최대한 빠른 합의를 위해 모든 노드들과 연결되어 있으며, proxy network를 앞에 내세움

-Endpoint 노드가 되기 위한 별다른 조건은 없으며, boothnode는 연결에 도움을 주는 특수유형 노드

</hr>

### 4. 코어 셸

-사용자가 많아져서 확장이 필요할 때

일반: 서버를 늘리고 request 분할 처리

klaytn: 노드 자체의 성능을 늘림

CNN(합의노드) 참여 조건

physical core 가 40개 이상

256 GBRAM

3)1년치의 데이터 약 14TB 저장

10G 네트워크
cf) 하나의 코어 셸이 빠르다고 해서 전체 성능이 올라가는 것은 아님!

-PN(프록시 노드)이 여러 대 연결된 이유

CN- 연결에 필요한 자원 제한적, 수가 한정적

https://user-images.githubusercontent.com/57217495/68576153-e753b780-04b0-11ea-8575-694b9b10031d.PNG


결론:

CN은 합의 담당 노드 -> connection에 방해 받으면 안됨

PN이 CN을 보호해주는 역할

PN을 여러 대 둠으로써 확장성 문제 해결 가능

</hr>

### 5. 서비스 체인

서비스 체인= 메인 체인의 "신뢰성을 고정"시키는 역할

</hr>

### 6. 이더리움과 클레이튼의 차이

이더리움
-단일 네트워크

-가장 먼저 블록을 만들고 전파해야함

-Proof of Work(작업증명)

-마이닝 노드: 블록을 쓰고 네트워크에 전파한 노드

2)클레이튼

-two layer architecture trust model

-매 라운드 마다 합의노드들 중 하나가 뽑혀서 블록을 씀

-사용자의 의도에 따라 퍼블릭/프라이빗 용도가 결정됨

<결론>

klaytn은 두 개의 레이어가 서로 신뢰하는 네트워크로 내부 블록체인에 접근 할 때

endpoint 노드가 corecell network에 연결해서 빠르게 데이터를 쓰거나 받을 수 있는 구조

이더리움과 klaytn은 크게 두 가지 차이점을 지니고 있음

메인넷과의 연결성: 이더리움은 메인넷 안에 있는 반면 클레이튼은 메인넷과 분리되어 있음.

네트워크 구조: 이더리움은 단일 네트워크인 반면 클레이튼은 corecell+ end node의 two layer 구조를 지님.

참고) Klaytn IDE와 remix IDE가 유사함.

## Week2 과제

Baobab까지 인프런 강의 듣고 오류난 상태로 가져오기!
